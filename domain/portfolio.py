# domain/portfolio.py
from __future__ import annotations

import time
from typing import Optional, TYPE_CHECKING

from config import ASSETS, MAX_TRADE_HISTORY

if TYPE_CHECKING:
    from domain.models import LobbyState, PlayerState


def pos_unrealized_upnl(qty: int, avg: float, price: float) -> float:
    """
    Computes the unrealized PnL (Profit and Loss) of a single open position.

    Unrealized PnL measures how much profit or loss the player *would* have
    if the position were closed at the current market price. Because the
    position is still open, this value is floating and updates every tick.

    Parameters
    ----------
    qty : int
        Net position quantity:
        - qty > 0 : long position
        - qty < 0 : short position
        - qty = 0 : no open position

    avg : float
        The volume-weighted average entry price of the position.

    price : float
        The current market price of the asset.

    Returns
    -------
    float
        The unrealized PnL of the position:
        
        - For a long position:
              (current_price - average_price) * quantity
        - For a short position:
              (average_price - current_price) * |quantity|
        - For no position:
              0.0

    Notes
    -----
    Longs profit when price goes up; shorts profit when price goes down.
    This function handles both cases by checking the sign of `qty`.

    Examples
    --------
    Long example:
        qty = 10, avg = 100, price = 110
        upnl = (110 - 100) * 10 = +100

    Short example:
        qty = -5, avg = 100, price = 90
        upnl = (100 - 90) * 5 = +50

    If qty == 0, the unrealized PnL is always 0.
    """
    if qty > 0:  # long
        return (price - avg) * qty
    if qty < 0:  # short
        return (avg - price) * (-qty)
    return 0.0


def record_trade(pl: PlayerState, *, asset: str, side_open: str, qty: int,
                 entry_price: float, exit_price: float,
                 entry_ts: Optional[float]):
  """
  Records a completed trade for a player and updates their realized PnL.

    This function is called whenever a position (or part of a position) is closed.
    It computes the realized profit or loss generated by the close, updates the
    player's cumulative realized PnL, and appends a structured trade record to
    the player's history.

    Parameters
    ----------
    pl : PlayerState
        The player's state object whose PnL and trade history will be updated.

    asset : str
        The asset symbol being traded (e.g., "OIL", "GOLD").

    side_open : str
        Indicates whether the *original* position being closed was a:
        - "LONG" : the player bought first and is now selling
        - "SHORT": the player sold first and is now buying to cover

    qty : int
        The quantity of the position being closed. Always a positive integer here,
        since the sign of the position is encoded in `side_open`.

    entry_price : float
        The price at which the position was originally opened.

    exit_price : float
        The price at which the position is now being closed.

    entry_ts : Optional[float]
        Timestamp (UNIX) marking when the position was opened.
        Used to compute the duration of the trade. If None, duration is omitted.

    Returns
    -------
    None
        The function updates the PlayerState in-place.

    Realized PnL Logic
    ------------------
    For longs:
        realized = (exit_price - entry_price) * qty

    For shorts:
        realized = (entry_price - exit_price) * qty

    This follows standard market microstructure:
    - Longs profit when price increases.
    - Shorts profit when price decreases.

    Side Effects
    ------------
    1. Adds the realized PnL to `pl.realized_pnl`.
    2. Appends a trade record to `pl.trades`, containing:
        - timestamp of close
        - asset symbol
        - side ("LONG" or "SHORT")
        - quantity
        - entry price (rounded to 4 decimals)
        - exit price (rounded to 4 decimals)
        - realized PnL (rounded to 2 decimals)
        - trade duration in seconds (if entry_ts is provided)

    3. If the trade history exceeds MAX_TRADE_HISTORY,
       the oldest entries are discarded to keep memory bounded.

    Notes
    -----
    - This function does *not* update positions. That is handled by the
      execution engine. `record_trade` only handles bookkeeping once a
      position is already closed.
    
    - The trade record structure is UI-friendly and serialized easily
      through WebSockets for display in trade history panels or leaderboards.
  """
  if side_open == "LONG":
    realized = (exit_price - entry_price) * qty
  else:
    realized = (entry_price - exit_price) * qty
  pl.realized_pnl += realized
  pl.trades.append({
      "ts":
      time.time(),
      "asset":
      asset,
      "side_open":
      side_open,
      "qty":
      qty,
      "entry_price":
      round(entry_price, 4),
      "exit_price":
      round(exit_price, 4),
      "realized_pnl":
      round(realized, 2),
      "duration_sec":
      round((time.time() - entry_ts), 2) if entry_ts else None
  })
  if len(pl.trades) > MAX_TRADE_HISTORY:
    pl.trades = pl.trades[-MAX_TRADE_HISTORY:]


def snapshot_portfolio(lobby: LobbyState, pl: PlayerState) -> dict:
  """
      Builds a full portfolio snapshot for a player, including cash, equity,
    unrealized PnL, realized PnL, and per-asset position details.

    This function aggregates all components of a player's current financial state
    and formats them into a dictionary suitable for sending through WebSockets
    or displaying in the UI. It uses the lobby's current market prices to compute
    valuations and unrealized PnL.

    Parameters
    ----------
    lobby : LobbyState
        The lobby containing the current simulated market prices for each asset.

    pl : PlayerState
        The player whose portfolio is being evaluated.

    Returns
    -------
    dict
        A complete snapshot of the player's portfolio, containing:
        - type:        always "PORTFOLIO"
        - cash:        available cash balance
        - equity:      cash + market value of open positions
        - uPnL:        total unrealized profit and loss
        - realizedPnL: cumulative closed PnL
        - positions:   list of per-asset position details
        - trades:      most recent closed trades (last 50)

    Portfolio Valuation Logic
    -------------------------
    For each asset in ASSETS:
        qty    = position quantity
        avg    = volume-weighted average entry price
        price  = current market price (from lobby)

        unrealized PnL:
            uPnL = pos_unrealized_upnl(qty, avg, price)

        market value:
            mktValue = qty * price

    Equity:
        equity = cash + total_market_value

    Unrealized PnL:
        Sum of unrealized PnL across all assets.

    Output Format Per Position
    --------------------------
    Each position entry in "positions" has the structure:
        {
            "asset":     symbol,
            "qty":       current quantity,
            "avg":       average entry price,
            "price":     current market price,
            "mktValue":  qty * price,
            "uPnL":      unrealized PnL for this position
        }

    Notes
    -----
    - This function does NOT modify any player state; it is read-only.
    - Intended for real-time UI updates sent over WebSockets.
    - Returns only the last 50 closed trades to keep payloads small.
  """
  upnl_total = 0.0
  mkt_value_total = 0.0
  rows = []
  for a in ASSETS:
    pos = pl.positions[a]
    qty, avg = pos["qty"], pos["avg"]
    price = lobby.prices[a]
    upnl = pos_unrealized_upnl(qty, avg, price)
    mkt_value = qty * price
    upnl_total += upnl
    mkt_value_total += mkt_value
    rows.append({
        "asset": a,
        "qty": qty,
        "avg": round(avg, 2),
        "price": round(price, 2),
        "mktValue": round(mkt_value, 2),
        "uPnL": round(upnl, 2)
    })
  equity = pl.cash + mkt_value_total
  return {
      "type": "PORTFOLIO",
      "cash": round(pl.cash, 2),
      "equity": round(equity, 2),
      "uPnL": round(upnl_total, 2),
      "realizedPnL": round(pl.realized_pnl, 2),
      "positions": rows,
      "trades": pl.trades[-50:]
  }


def leaderboard(lobby: LobbyState):
  """
    Build and return the leaderboard for all players in a lobby.

    This function computes each player's current performance by calculating
    their mark-to-market equity (cash + market value of all open positions)
    and their cumulative realized PnL. It then sorts all players in descending
    order of equity to produce a real-time ranking suitable for display in the UI.

    Parameters
    ----------
    lobby : LobbyState
        The current lobby state, which contains:
        - all active players (`lobby.players`)
        - current market prices for every tradable asset (`lobby.prices`)

    Computation Details
    -------------------
    For each player:
        - Market value (mark-to-market) is computed as:
              mv = sum( qty(asset) * price(asset) )
        - Equity is then:
              equity = cash + mv
        - Realized PnL is taken from the PlayerState.

    Returns
    -------
    dict
        A dictionary structured as:

        {
          "type": "LEADERBOARD",
          "rows": [
             {
                "userId": <player ID>,
                "name": <player name>,
                "equity": <cash + mark-to-market value>,
                "realizedPnL": <cumulative realized PnL>
             },
             ...
          ]
        }

        The rows are sorted by equity in descending order, placing the best
        performing trader at the top of the leaderboard.

    Notes
    -----
    - This function does **not** modify the lobby state; it only reads data.
    - Equity represents total account value and is the standard metric for
      ranking players in trading competitions or simulations.
    - The leaderboard can be sent periodically (e.g., every tick) to update the
      UI in real time.
  """
  rows = []
  for uid, pl in lobby.players.items():
    # compute equity (mark-to-market)
    mv = 0.0
    for a in ASSETS:
      mv += pl.positions[a]["qty"] * lobby.prices[a]
    rows.append({
        "userId": uid,
        "name": pl.name,
        "equity": round(pl.cash + mv, 2),
        "realizedPnL": round(pl.realized_pnl, 2),
    })
  rows.sort(key=lambda r: r["equity"], reverse=True)
  return {"type": "LEADERBOARD", "rows": rows}
